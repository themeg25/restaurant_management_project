from django.db import models

class MenuCategory(models.Model):
    name = models.CharField(max_length=100, unique=True)

        def __str__(self):
                return self.name


                class MenuItem(models.Model):
                    name = models.CharField(max_length=255)
                        price = models.DecimalField(max_digits=8, decimal_places=2)  # ðŸ’° Price stored as Decimal
                            description = models.TextField(blank=True)
                                category = models.ForeignKey(MenuCategory, on_delete=models.CASCADE, related_name='menu_items')

                                    def __str__(self):
                                            retufrom rest_framework import serializers
                                            from .models import MenuItem
                                            
                                            class MenuItemSerializer(serializers.ModelSerializer):
                                                category = serializers.StringRelatedField()
                                                
                                                    class Meta:
                                                            model = MenuItem
                                                                    fields = ['id', 'name', 'price', 'desfrom rest_framework import generics, status
                                                                    from rest_framework.response import Response
                                                                    from .models import MenuItem
                                                                    from .serializers import MenuItemSerializer
                                                                    
                                                                    class MenuItemPriceRangeView(generics.ListAPIView):
                                                                        """
                                                                            API endpoint to retrieve menu items within a specified price range.
                                                                                Accepts query parameters:
                                                                                      - min_price
                                                                                            - max_price
                                                                                                Example:
                                                                                                      /api/menu-items/price-range/?min_price=5&max_price=15
                                                                                                          """
                                                                                                              serializer_class = MenuItemSerializer
                                                                                                              
                                                                                                                  def get_queryset(self):
                                                                                                                          queryset = MenuItem.objects.all()
                                                                                                                                  min_price = self.request.query_params.get('min_price')
                                                                                                                                          max_price = self.request.query_params.get('max_price')
                                                                                                                                          
                                                                                                                                                  # Filter only if both values are provided
                                                                                                                                                          if min_price is not None and max_price is not None:
                                                                                                                                                                      try:
                                                                                                                                                                                      min_price = float(min_price)
                                                                                                                                                                                                      max_price = float(max_price)
                                                                                                                                                                                                      
                                                                                                                                                                                                                      if min_price < 0 or max_price < 0:
                                                                                                                                                                                                                                          raise ValueError("Price cannot be negative.")
                                                                                                                                                                                                                                                          if min_price > max_price:
                                                                                                                                                                                                                                                                              raise ValueError("min_price cannot be greater than max_price.")
                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                              queryset = queryset.filter(price__gte=min_price, price__lte=max_price)
                                                                                                                                                                                                                                                                                                          except ValueError as e:
                                                                                                                                                                                                                                                                                                                          # Weâ€™ll raise it here and catch in list() for cleaner error response
                                                                                                                                                                                                                                                                                                                                          raise e
                                                                                                                                                                                                                                                                                                                                          
                                                                                                                                                                                                                                                                                                                                                  return queryset
                                                                                                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                                                                                                      def list(self, request, *args, **kwargs):
                                                                                                                                                                                                                                                                                                                                                              try:
                                                                                                                                                                                                                                                                                                                                                                          return super().list(request, *args, **kwargs)
                                                                                                                                                                                                                                                                                                                                                                                  except ValueError as e:
                                                                                                                                                                                                                                                                                                                                                                                              return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)
                                                                                                                                                                                                                                                                                                                                                                                                      except Exception as e:
                                                                                                                                                                                                                                                                                                                                                                                                                  return Response({"error": "An unexpected error occurred."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)cription', 'category']rn self.name